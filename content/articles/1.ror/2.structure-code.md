---
title: "Ruby - Structure du code"
description: "FaÃ§on simple et modulable d'organiser votre application Ruby on Rails en mode API."
icon: "i-mdi:language-ruby"
color: "red"
article_id: "1-ror-structure-code"
---

#### ğŸ“Œ Vous utilisez une application Ruby on Rails en mode API ?

Alors, vous savez combien il peut rapidement devenir compliquÃ© de gÃ©rer tout le code mÃ©tier lorsque tout est regroupÃ© dans les contrÃ´leurs ou les modÃ¨les.

Pour garder votre code clair, simple Ã  tester et Ã  faire Ã©voluer, il est vraiment conseillÃ© de structurer votre projet de faÃ§on modulaire, en rÃ©servant Ã  chaque type de logique sa propre place.

Dans cet article, je vous propose une organisation simple mais trÃ¨s efficace : utiliser des services pour les actions mÃ©tier ponctuelles, des procÃ©dures pour coordonner plusieurs Ã©tapes, des forms pour valider les donnÃ©es en entrÃ©e, et dâ€™autres dossiers spÃ©cialisÃ©s (jobs, mailers, queries, etc...) pour rÃ©partir les responsabilitÃ©s.

Cette approche facilite la lecture du code, accÃ©lÃ¨re les tests, et permet de rÃ©utiliser facilement vos composants, le tout dans une architecture orientÃ©e API.

##### ğŸ“‚ Structure de l'application

Lâ€™architecture que je vous suggÃ¨re repose sur une sÃ©paration claire des responsabilitÃ©s.

Chaque type de logique trouve sa place dans un rÃ©pertoire dÃ©diÃ©, ce qui permet dâ€™avoir un code lisible, facile Ã  tester et simple Ã  maintenir sur le long terme.

```bash
app/
â”œâ”€â”€ controllers/          # ContrÃ´leurs API, lÃ©gers, appellent services/procedures
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ v1/
â”œâ”€â”€ models/               # ModÃ¨les ActiveRecord
â”œâ”€â”€ serializers/          # Pour formater les rÃ©ponses JSON (ActiveModel::Serializer, FastJSONAPI, etc.)
â”‚   â””â”€â”€ user_serializer.rb
â”œâ”€â”€ services/             # Actions unitaires mÃ©tiers
â”‚   â””â”€â”€ users/
â”‚       â””â”€â”€ create_user.rb
â”œâ”€â”€ procedures/           # EnchaÃ®nement de services mÃ©tier
â”‚   â””â”€â”€ onboarding/
â”‚       â””â”€â”€ register_user.rb
â”œâ”€â”€ jobs/                 # Pour les traitements asynchrones
â”œâ”€â”€ mailers/              # Pour les emails (mÃªme en API)
â”œâ”€â”€ queries/              # Pour encapsuler les requÃªtes complexes
â”œâ”€â”€ policies/             # Autorisation (Pundit ou maison)
â”œâ”€â”€ forms/                # Objets de formulaire si besoin (ActiveModel)
â”œâ”€â”€ presenters/           # (Facultatif) pour enrichir les donnÃ©es avant serialisation
â””â”€â”€ validators/           # Validations personnalisÃ©es (ex: pour des schÃ©mas JSON)
```

```bash
app/
â”œâ”€â”€ controllers/          # ContrÃ´leurs API, lÃ©gers, appellent services/procedures
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ v1/
```

Les contrÃ´leurs ne contiennent plus de logique mÃ©tier.

Ils se contentent de recevoir les requÃªtes, dâ€™appeler les procÃ©dures ou services appropriÃ©s, et de retourner une rÃ©ponse JSON.

```bash
â”œâ”€â”€ models/               # ModÃ¨les ActiveRecord
```

Les modÃ¨les restent liÃ©s aux entitÃ©s de la base de donnÃ©es. Ils sont allÃ©gÃ©s au maximum en externalisant les validations complexes ou la logique mÃ©tier vers d'autres couches (forms, services, validatorsâ€¦).

```bash
â”œâ”€â”€ serializers/          # Pour formater les rÃ©ponses JSON
â”‚   â””â”€â”€ user_serializer.rb
```

Les serializers (comme ActiveModel::Serializer, FastJSONAPI, ou Blueprinter) transforment les objets Ruby en formats JSON adaptÃ©s Ã  lâ€™API.

```bash
â”œâ”€â”€ services/             # Actions unitaires mÃ©tiers
â”‚   â””â”€â”€ users/
â”‚       â””â”€â”€ create_user.rb
```

Les services encapsulent une seule action mÃ©tier cohÃ©rente, testable indÃ©pendamment.

Exemples : crÃ©er un utilisateur, envoyer une notification, appliquer une rÃ©duction.

```bash
â”œâ”€â”€ procedures/           # EnchaÃ®nement de services mÃ©tier
â”‚   â””â”€â”€ onboarding/
â”‚       â””â”€â”€ register_user.rb
```

Les procÃ©dures orchestrent plusieurs services dans une logique plus large.

Par exemple : lâ€™onboarding utilisateur, qui inclut la crÃ©ation du compte, lâ€™envoi dâ€™un e-mail de bienvenue et la crÃ©ation dâ€™un panier par dÃ©faut.

```bash
â”œâ”€â”€ jobs/                 # Pour les traitements asynchrones
```

Les jobs contiennent les tÃ¢ches longues ou non critiques Ã  exÃ©cuter en arriÃ¨re-plan via ActiveJob (par ex. envoi dâ€™e-mails, export CSV, synchronisation externe...).

```bash
â”œâ”€â”€ mailers/              # Pour les emails (mÃªme en API)
```

MÃªme dans une API, des mailers peuvent Ãªtre utiles pour les notifications (confirmation dâ€™inscription, rÃ©initialisation de mot de passe, etc.).

```bash
â”œâ”€â”€ queries/              # Pour encapsuler les requÃªtes complexes
```

Les queries regroupent les accÃ¨s complexes Ã  la base de donnÃ©es (avec ActiveRecord, arel, ou raw SQL). Cela permet de nommer, tester et rÃ©utiliser des sÃ©lections spÃ©cifiques.

```bash
â”œâ”€â”€ policies/             # Autorisation (Pundit ou maison)
```

Les policies centralisent les rÃ¨gles d'autorisation. UtilisÃ©es avec Pundit ou un systÃ¨me interne, elles gardent les contrÃ´leurs et services focalisÃ©s sur leur rÃ´le.

```bash
â”œâ”€â”€ forms/                # Objets de formulaire si besoin (ActiveModel)
```

Les forms utilisent ActiveModel::Model pour valider les donnÃ©es complexes dâ€™un formulaire ou dâ€™un endpoint. Ils sont utiles lorsquâ€™on sort des simples validations ActiveRecord.

```bash
â”œâ”€â”€ presenters/           # (Facultatif) pour enrichir les donnÃ©es avant serialisation
```

Les presenters servent Ã  enrichir ou transformer les objets Ã  exposer (ex : formatage HTML, calculs de champs, regroupement de donnÃ©es). Optionnels mais utiles quand les serializers deviennent trop lourds.

```bash
â””â”€â”€ validators/           # Validations personnalisÃ©es (ex: pour des schÃ©mas JSON)
```

Les validators dÃ©finissent des rÃ¨gles personnalisÃ©es rÃ©utilisables, en particulier pour les validations mÃ©tiers, les structures JSON entrantes, ou des formats spÃ©cifiques (SIRET, IBAN, etc.).

Cette structure facilite le maintien d'un code mÃ©tier indÃ©pendant du framework, ce qui le rend plus simple Ã  tester en isolation et prÃªt Ã  Ã©voluer sereinement, sans risquer de crÃ©er de la dette technique.

##### ğŸ“‚ Structure des tests

Pour accompagner une architecture bien organisÃ©e cÃ´tÃ© app/, la structure de test dans spec/ doit reflÃ©ter cette sÃ©paration des responsabilitÃ©s. Cela facilite le repÃ©rage, l'Ã©criture et la maintenance des tests unitaires et dâ€™intÃ©gration.

```bash
spec/
â”œâ”€â”€ requests/            # Pour tester les endpoints (status + JSON)
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ v1/
â”œâ”€â”€ services/            # Tests unitaires des services
â”œâ”€â”€ procedures/          # Tests unitaires des procÃ©dures
â”œâ”€â”€ serializers/         # Tests des structures JSON (optionnel mais utile)
â”œâ”€â”€ jobs/                # VÃ©rifie que les jobs s'enquÃªtent bien
â”œâ”€â”€ policies/            # Tests des droits
```

```bash
spec/
â”œâ”€â”€ requests/            # Pour tester les endpoints (status + JSON)
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ v1/
```

Les tests de requÃªtes couvrent les endpoints exposÃ©s par lâ€™API : vÃ©rification des statuts HTTP, des structures JSON, de lâ€™authentification et de la gestion des erreurs.

Ces tests se rapprochent du comportement rÃ©el cÃ´tÃ© client.

```bash
â”œâ”€â”€ services/            # Tests unitaires des services
```

Les services Ã©tant des actions mÃ©tier isolÃ©es, ils sont testÃ©s de faÃ§on unitaire : on vÃ©rifie lâ€™effet attendu, les effets de bord (crÃ©ation dâ€™objets, envois, etc.) et les cas dâ€™erreur.

```bash
â”œâ”€â”€ procedures/          # Tests unitaires des procÃ©dures
```

Les procÃ©dures orchestrant plusieurs services, leurs tests vÃ©rifient le bon enchaÃ®nement des Ã©tapes, la gestion des Ã©checs partiels, et les effets globaux de bout en bout.

```bash
â”œâ”€â”€ serializers/         # Tests des structures JSON (optionnel mais utile)
```

Ces tests assurent que les serializers produisent bien les bons formats JSON.

Cela permet dâ€™Ã©viter des rÃ©gressions sur des structures exposÃ©es Ã  des clients externes (frontends, partenaires, etc.).

```bash
â”œâ”€â”€ jobs/                # VÃ©rifie que les jobs s'enquÃªtent bien
```

On teste que les jobs sont bien dÃ©clenchÃ©s (avec have_enqueued_job, perform_enqueued_jobs, etc.), et quâ€™ils effectuent la tÃ¢che attendue sans effets indÃ©sirables.

On peut aussi vÃ©rifier leur gestion des erreurs.

```bash
â”œâ”€â”€ policies/            # Tests des droits
```

Les policies dÃ©finissent les rÃ¨gles dâ€™accÃ¨s.

Les tests vÃ©rifient que les bons rÃ´les peuvent ou non effectuer certaines actions sur les ressources (lecture, Ã©criture, suppressionâ€¦).

---

#### âš™ï¸ Exemple concret : enregistrement d'un utilisateur

###### 1. Procedure : `procedures/onboarding/register_user.rb`

```ruby
module Onboarding
  class RegisterUser
    def initialize(params)
      @form = Users::RegistrationForm.new(params)
    end

    def call
      return Result.failure(errors: @form.errors.full_messages) unless @form.valid?

      user = Users::CreateUser.new(@form.attributes).call
      return Result.failure(errors: user.errors.full_messages) unless user.persisted?

      Result.success(data: user)
    end
  end
end
```

###### 2. Form : `forms/users/registration_form.rb`

```ruby
module Users
  class RegistrationForm
    include ActiveModel::Model

    attr_accessor :email, :password, :password_confirmation

    validates :email, :password, :password_confirmation, presence: true
    validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
    validates :password, confirmation: true

    def attributes
      { email: email, password: password }
    end
  end
end
```

###### 3. Service : `services/users/create_user.rb`

```ruby
module Users
  class CreateUser
    def initialize(attributes)
      @attributes = attributes
    end

    def call
      User.create(@attributes)
    end
  end
end
```

###### 4. Serializer : `serializers/user_serializer.rb`

```ruby
class UserSerializer
  include JSONAPI::Serializer

  set_type :user
  attributes :id, :email, :created_at
end
```

###### 5. Controller : `controllers/api/v1/users_controller.rb`

```ruby
module Api
  module V1
    class UsersController < ApplicationController
      def create
        result = Onboarding::RegisterUser.new(user_params).call

        if result.success?
          render json: UserSerializer.new(result.data).serializable_hash.to_json, status: :created
        else
          render json: { errors: result.errors }, status: :unprocessable_entity
        end
      end

      private

      def user_params
        params.require(:user).permit(:email, :password, :password_confirmation)
      end
    end
  end
end
```

---

##### ğŸ”¬ Tests

###### `spec/procedures/onboarding/register_user_spec.rb`

```ruby
RSpec.describe Onboarding::RegisterUser do
  let(:params) { { email: "test@example.com", password: "secret123", password_confirmation: "secret123" } }

  subject(:result) { described_class.new(params).call }

  it "creates a user successfully" do
    expect(result).to be_success
    expect(result.data).to be_a(User)
  end

  context "with invalid data" do
    let(:params) { { email: "", password: "123", password_confirmation: "456" } }

    it "fails with errors" do
      expect(result).to be_failure
      expect(result.errors).to include("Email can't be blank")
    end
  end
end
```

###### `spec/services/users/create_user_spec.rb`

```ruby
RSpec.describe Users::CreateUser do
  let(:attributes) { { email: "user@example.com", password: "password" } }

  it "creates a user" do
    user = described_class.new(attributes).call

    expect(user).to be_persisted
    expect(user.email).to eq("user@example.com")
  end
end
```

###### `spec/serializers/user_serializer_spec.rb`

```ruby
RSpec.describe UserSerializer do
  let(:user) { create(:user) }

  it "serializes the user" do
    json = described_class.new(user).serializable_hash

    expect(json[:data][:attributes]).to include(:email)
  end
end
```

###### `spec/requests/api/v1/users_spec.rb`

```ruby
RSpec.describe "User Registration", type: :request do
  it "registers a new user" do
    post "/api/v1/users", params: {
      user: {
        email: "api@example.com",
        password: "password",
        password_confirmation: "password"
      }
    }

    expect(response).to have_http_status(:created)
    expect(JSON.parse(response.body)).to have_key("data")
  end

  it "returns errors with invalid data" do
    post "/api/v1/users", params: { user: { email: "" } }

    expect(response).to have_http_status(:unprocessable_entity)
    expect(JSON.parse(response.body)).to have_key("errors")
  end
end
```
